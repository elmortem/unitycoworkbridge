# Unity Bridge Skill

Скилл для генерации и выполнения C# скриптов в Unity Editor через Cowork Bridge.

## Шаблон генерируемого скрипта

Все генерируемые скрипты ОБЯЗАНЫ следовать этому шаблону:

```csharp
using UnityEngine;
using UnityEditor;

public static class Task_XXX
{
    public static string Run()
    {
        // сгенерированный код
        return "описание результата";
    }
}
```

Правила:
- `public static class` с `public static string Run()`
- Имя класса совпадает с именем файла (без расширения)
- Метод возвращает строку с описанием того, что было сделано
- Для вывода информации использовать `Debug.Log()` — логи перехватываются и включаются в результат
- Не добавлять зависимости от пользовательских сборок проекта

## Кастомные API проекта

Перед генерацией скрипта найди все файлы `UNITYCOWORK.md` в Unity проекте (рекурсивный поиск от корня проекта). Каждый такой файл описывает кастомный API, доступный в проекте. Прочитай все найденные файлы и используй описанные в них классы и методы при генерации скрипта, если они подходят для задачи.

Если файлов `UNITYCOWORK.md` не найдено или ни один из описанных API не подходит для задачи — используй стандартное Unity Editor API.

## Протокол выполнения задачи

### Шаг 1: Определить имя задачи

Формат: `Task_YYYYMMDD_HHMMSS`

Пример: `Task_20260226_143052`

### Шаг 2: Найти кастомные API

Выполнить поиск файлов `UNITYCOWORK.md` в проекте. Прочитать все найденные. Определить, какие из описанных API применимы к текущей задаче.

### Шаг 3: Сгенерировать скрипт

Создать файл `Assets/Editor/CoworkBridge/<TaskName>.cs` по шаблону выше. Код должен решать задачу пользователя, используя кастомные API (если подходят) или стандартное Unity Editor API.

Bridge автоматически подхватывает новые `.cs` файлы в `Assets/Editor/CoworkBridge/` и обрабатывает их последовательно. Никаких дополнительных файлов задач создавать не нужно — сам скрипт и есть задача.

### Шаг 4: Ожидание результата

Запустить скрипт ожидания:

```bash
bash scripts/wait_result.sh <TaskName> 300
```

Скрипт вернёт JSON с результатом через stdout.

### Шаг 5: Обработка результата

Прочитать `Assets/Editor/CoworkBridge/result_<TaskName>.json` и действовать по логике ошибок.

## Логика обработки ошибок

### status == "success"

Показать пользователю `logs` и `return_value`.

### status == "compiler_error" И foreign_errors == false

1. Изучить ошибки компилятора из `compiler_errors`
2. Исправить сгенерированный скрипт `Assets/Editor/CoworkBridge/<TaskName>.cs`
3. Снова запустить `wait_result.sh` и проверить результат (Bridge подхватит изменённый файл автоматически)
4. Максимум 3 итерации исправлений
5. Если после 3 итераций ошибки остались — показать их пользователю

### status == "compiler_error" И foreign_errors == true

Остановиться немедленно. Сообщить пользователю:
- В проекте есть ошибки компиляции в других файлах
- Показать какие именно файлы и ошибки
- НЕ пытаться исправлять чужие файлы

### status == "runtime_error"

Показать пользователю логи ошибки. При необходимости предложить исправление.
