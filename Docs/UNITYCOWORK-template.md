# Шаблон UNITYCOWORK.md

## Зачем нужен этот файл

Unity Cowork Bridge выполняет задачи пользователя через автоматически генерируемые C# скрипты. ИИ генерирует статический класс с методом `Run()`, который запускается внутри Unity Editor:

```csharp
public static class Task_20260226_143052
{
    public static string Run()
    {
        // сгенерированный код — вызовы Unity API или кастомных API
        return "описание результата";
    }
}
```

Перед генерацией скрипта ИИ ищет в проекте все файлы `UNITYCOWORK.md` и читает их. Если описанный в файле API подходит для задачи пользователя — ИИ использует его вместо стандартного Unity Editor API.

**Ваша задача как автора библиотеки** — написать `UNITYCOWORK.md`, который объяснит ИИ:
1. Для каких задач пользователя применять ваш API (домены, ключевые слова)
2. Какие методы вызывать из `Run()` и с какими параметрами
3. Готовые примеры кода, которые ИИ может взять за основу

## Формат файла

```markdown
# Название API

Одно предложение: что делает API. Второе предложение: когда ИИ должен предпочесть его стандартному Unity API.

## Домен

Список ключевых слов и типов задач пользователя, при которых нужно использовать этот API.
ИИ сопоставляет запрос пользователя с этим списком. Пишите на языке пользователя —
как он формулирует задачу, а не как называется класс в коде.

## Using

Какие using добавить в скрипт.

## API

Публичные методы и классы, которые можно вызвать из Run().
Показывайте сигнатуры и краткое описание каждого метода.
Не описывайте внутренности — только то, что вызывает потребитель.

## Примеры

Готовые фрагменты кода внутри метода Run(). Каждый пример —
конкретный сценарий, который ИИ может адаптировать под задачу пользователя.
```

## Рекомендации

- **Думайте от задачи пользователя, а не от класса.** Пользователь скажет «создай префабы врагов из спрайтов», а не «вызови Prefab2DBuilder». Секция «Домен» должна содержать формулировки пользователя.
- **Примеры — это главное.** ИИ лучше всего работает с конкретным кодом. Каждый пример должен быть рабочим фрагментом, который можно вставить в `Run()` и он скомпилируется.
- **Пишите кратко.** Файл читается при каждом запуске задачи. Не дублируйте полную документацию — покажите только то, что нужно для вызова из скрипта.
- **Один файл — одна логическая область.** Если в библиотеке есть билдеры и утилиты — это два разных файла.
- **Располагайте файл рядом с кодом**, который он описывает.

## Пример готового файла

Ниже — пример `UNITYCOWORK.md` для гипотетического API генерации тайлмапов:

```markdown
# TilemapGenerator

Программная генерация тайлмапов из набора тайлов. Используй вместо ручной настройки Tilemap, когда нужно создать или заполнить тайлмап из кода.

## Домен

- создать тайлмап, сгенерировать тайлмап, заполнить тайлмап
- карта уровня, процедурная генерация уровня
- расставить тайлы, заполнить сетку тайлами

## Using

⁣```csharp
using MyLib.Editor.Tilemap;
using UnityEngine.Tilemaps;
⁣```

## API

⁣```csharp
// Создаёт GameObject с Tilemap + TilemapRenderer, возвращает Tilemap
Tilemap TilemapGenerator.Create(string name, Grid parentGrid)

// Заполняет прямоугольную область одним тайлом
void TilemapGenerator.FillRect(Tilemap map, TileBase tile, BoundsInt area)

// Заполняет тайлмап по шаблону (2D массив индексов тайлов)
void TilemapGenerator.FillFromPattern(Tilemap map, TileBase[] palette, int[,] pattern)
⁣```

## Примеры

Создать тайлмап 10×10, заполненный одним тайлом:

⁣```csharp
var grid = new GameObject("Level").AddComponent<Grid>();
var tile = AssetDatabase.LoadAssetAtPath<TileBase>("Assets/Tiles/Grass.asset");
var map = TilemapGenerator.Create("Ground", grid);
TilemapGenerator.FillRect(map, tile, new BoundsInt(0, 0, 0, 10, 10, 1));
PrefabUtility.SaveAsPrefabAsset(grid.gameObject, "Assets/Prefabs/Level.prefab");
Object.DestroyImmediate(grid.gameObject);
return "Создан тайлмап 10x10 с тайлом Grass";
⁣```
```
